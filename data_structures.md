# 数据结构 Data Structures {#data-structures}

数据结构 (data structure) 是能够储存**数据**的**结构**。换句话说，它们是储存相关数据的集合。

python 有四种数据结构——**列表 (list) ，元组 (tuple) ，字典 (dictionary) 和集合 (set)** 。我们将看到它们如何发挥作用。

## 列表 list

`list` 这种数据结构是一种有序集合，即你可以将**序列**储存在列表里。这不难理解，如果你能想到购物清单。当然，这其中可能也存在差异，你的购物清单可能是每行一项，而 python 中，你使用逗号 `,` 来隔开那些项。

列表中的项应该包含在中括号内，python 就能明白你要指定一个列表。在列表中可以添加，移除和搜索项。由于我们能能够添加和移除项，我们称列表为**可变**数据类型，即这种类型是可以更改的。

## 速览对象与类

尽管到现在我们还要推迟对象和类的相关讨论，但你还是需要一些解释来帮助理解列表。我们会在[后面的章节](./oop.md#oop)里继续探索这个话题。

列表是对象和类的应用之一。当我们使用变量 `i` 并为它赋值，比如说赋值为整数 `5` 的时候，你可以把这想做创建一个**类**（即类型）`int` 的**对象**（即实例）`i`。实际上，阅读 `help(int)` 可以帮助你了解。

类还可以有**方法 (method)** 即专属该类的函数。只有该类的对象可以使用这些方法。例如，python 为 ` list` 提供的 `append` 方法，该方法是的你可以在列表的末尾追加项。注意访问对象的方法使用的是点标记法。

一个类还能有**字段**，字段是专属该类的变量。只有该类的对象可以使用这些变量或名称。字段也使用点标记法访问，例如 `mylist.field` 。

请看示例 `ds_using_list.py` ：

<pre><code class="lang-python">{% include "./programs/ds_using_list.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/ds_using_list.txt" %}</code></pre>

**它是怎么做的**

变量 `shoplist` 是某兄台去市场购物的清单。在 `shoplist` 中，我们仅储存那些我们要买的项的名称。但是你可以添加**任意对象**到这个列表里，可以是数字，甚至是其他列表。

我们还使用了 `for..in` 循环来迭代列表中项。到此，你一定意识到列表也是序列。序列的特殊之处在[下面的部分](#sequence)会作更多探讨。

请注意，在 `print` 函数调用中的 `end` 参数说明我们用一个空格来做输出的结尾，而不是换行符。

接着，如我们前面所讲，我们使用列表对象的 `append` 方法向列表中添加项。然后，我们通过打印列表中的内容来检测这个项是否真的添加到了列表之中。要实现这个目的，我们只需将列表传递给 `print` 函数，它就能轻松的被打印出来。

再之后，我们使用列表的 `sort` 方法来将列表排序。一定要理解这个方法影响这个列表本身，而不是另造一个列表——这与字符串是不同的。这也是为何我们说列表是**可变的**，而字符串是**不可变的**。

最后，当我们在市场里购买完某项时，我们将之从列表中移除。使用 `del` 语句即可。在这里，我们要留意 `del` 语句会将为我们想要移除的那个项从列表中移除。我们指定想要移除的项是列表中的第一项，因此我们用 `del shoplist[0]`（请记住 python 从 0 开始计数）。

如果你下那个知道列表对象所有的方法，看看 `help(list)` 。

> `sort` 排序算法算是一个基本的算法和编程语言相关的联系。我在学习 python 的过程中，在编书的同时也写了一些排序算法，来巩固学习。它们在 [https://github.com/Wind2esg/python3sort](https://github.com/Wind2esg/python3sort) 。如果有兴趣，你可以去看一看。

## 元组 tuple

元组用以储存在一起的多个对象。它们和列表很像，只是没有列表类给你的那些伸缩方法。元组的一个主要特性就是**不可变**如同字符串那样。你不能修改元组。

元组的定义方法是在括号内指定项，这些项由逗号分隔。这里的括号是可选的。

如果能确定某语句或者某用户定义的函数的值得集合不会发生改变，通常我们使用元组。

请看示例 `ds_using_tuple.py` ：

<pre><code class="lang-python">{% include "./programs/ds_using_tuple.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/ds_using_tuple.txt" %}</code></pre>

**它是怎样做的**

变量 `zoo` 指的是一些项的元组。我们见到 `len` 函数可以用来获取元组的长度。这也说明了元组也是[序列 sequence](#sequence) 。

现在，由于老动物园关闭，我们将这些动物转移到新动物园里。因此，`new_zoo` 元组中包含了原本就在那的动物以及从老动物园带过来的动物。回归现实，请注意在被元组内的元组仍是元组。

就像在列表中那样，我们可以通过在一对中括号内指定项的位置来访问元组中的项。这种使用形式被称作**索引 (indexing)** 运算符。我们使用 `new_zoo[2]` 指定 `new_zoo` 的第三项，用 `new_zoo[2][2]` 来指定 `new_zoo` 元组的第三项内的第三项。如果你明白这个用法，这还是很简单的。

> **没有或者仅有一项的元组**
> 
> 空元组通过一对内中为空的括号构造，如 `myempty = ()` 。但是，当元组仅有一个项时，就没那么简单了。你不许使用一个逗号在这仅有的项之后，以求 python 能去分辨是一个元组还是某表达式中包围对象的一对括号，也就是说，如果你想要一个仅包含一个项 `2` 的元组，你必须像 `singleton = (2 , )` 这样来指定它。
> 这是我首次见到这样的语法。

<!-- -->

> 被包含在列表之内的列表不会失去它的身份指的是列表不会像在 Perl 中那样被摊平。这个道理同样适用于元祖中的元组，或列表中的元组，或元祖中的列表等。python 看来，它们只是储存在其他对象中的对象。仅此而已。

## 字典 dictionary

字典有些像地址簿，你只需知道他或她的名称，就能找到这个人的地址或者详细联系方式，也就是说，我们将**键 (key)** 与**值**相联系。请记好，键必须是唯一的，就好像如果你的地址簿有重名的两个人，你就没法确认信息。

还要注意对于字典的键只能使用不可变对象如字符串，对于值，可变不可变皆可。也就是说你仅能使用简单对象作为键。

在字典中指定键值对 (pair) 使用的标记如 `d = {key1 : value1, key2 : value2 }` 。请注意，键和值使用冒号 `:` 隔开，本身是被逗号隔开，所有这些都包含在一对花括号内。

请记住，字典中的键值对是无序的。如果你想要其呈现出某种顺序，你必须在使用前对它们自行排序。

你使用的字典是 `dict` 类的对象或实例。

请看示例 `ds_using_dict.py` ：

<pre><code class="lang-python">{% include "./programs/ds_using_dict.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/ds_using_dict.txt" %}</code></pre>

**它怎样做到的**

我们使用之前探讨过的标记方式创建了字典 `ab` 。接着我们再在通过列表和元组内容中讲过的索引操作符中指定键来访问其中的键值对。看看这语法多简单。

我们使用老朋友—— `del` 语句来删除键值对。我们简单的指定字典，在索引操作符中指定想要移除的那个键值对的键，将其传递给 `del` 语句。整个操作中，我们不需知晓与此键相对应的值是什么。

接着，我们使用字典中的 `item` 方法来遍历字典中的每一对键值对。`items` 方法返回一个元组的列表，内中每一个元组都包含一对项——键与紧随其后的值。通过 `for..in` 循环，我们获取到每一对键值对并将其相应的赋值给变量 `name` 和 `address`，最后在 for-block 中打印。

增加新的键值对只需要使用索引操作符访问键并复制就可以，如我们在上例中对 Guido 的操作。

我们可以使用 `in` 操作符来检测某键值对是否存在。

`help(dict)` 可以给你 `dict` 类的方法列表。

> **关键字参数和字典**
> 
> 如果你再函数中使用了关键字参数，那么你已经使用过字典了。想想——你在函数定义的参数列表中指定了键值对，你在函数中访问那些变量，其实就是在访问字典的键（这在编译器设计术语中被称为**符号表 (symbol table)** ）。

## 序列 sequence

列表，元素和字符串都是序列，但是序列究竟是什么，又有何特殊之处？

它最主要的特性是**成员关系测试 (membership test)** ，即 `in` 和 `not in` 表达式，和允许我们从序列中获取特定项的**索引操作 (indexing operation)** 。

之前提到的三种序列——列表，元组和字符串，都还有一种**切片**操作，这个操作使得我们能从序列中获取一段切片，即序列的某一部分。

请看示例 `ds_seq.py` ：

<pre><code class="lang-python">{% include "./programs/ds_seq.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/ds_seq.txt" %}</code></pre>

**它是怎样做的**

首先，我们看到怎样使用索引来单独获取序列中的项。这也被称作**下标操作 (subscription operation)** 。无论何时，只要我们像上面那样在中括号内指定一个数字，python 将会获取到序列中与该位置相对应的项。请记住，python 从 0 开始计数。因此在`shoplist` 序列中， `shoplist[0]` 会获取第一项，而 `shoplist[3]` 会获取第四项。

索引也可以是一个负数，上例中，位置从序列末尾开始计算。因此，`shoplist[-1]` 指的是最后一项，`shoplist[-2]` 获取的是倒数第二项。

切片操作使用方式是指定序列名称，中括号紧随其后，中括号内是一对使用冒号隔开的数字。请注意，这与目前使用的索引操作很相似。请记好，数字是可选的，但冒号是必须有的。

第一个数，即冒号前的数，在切片操作中指示切片的起点，第二个数，也就是冒号之后的数，代表切片终点。如果第一个数没有被指明，那么 python 会认为切片的起点是序列的开头。如果第二个数字留空，python 将序列的末尾当做切片的重点。值得注意的是切片**始于**起点，但**止于**终点前，也就是说，起点位置是被包含在内的，但终点位置不被包含。

依此，`shoplist[1:3]` 返回序列的一个切片，这个切片起点在 1 ，包括位置 2 但停在了位置 3 。所以结果返回的是一个含有两项的**切片**。类似的 `shoplist[:]` 将返回整个序列的一个副本。

你还可以使用负的位置来做切片。负数是指从序列末尾开始计算。例如 `shoplist[:-1]` 将会返回一个包含除序列最后一项之外的所有项的切片。

> 切片的用法还是很有意思的。
>
> 它让我想起了高中化学课本中德国化学家凯库勒 FriedrichA·Kekule 长期探究苯环结构，终有一晚，他梦见一条咬住自己尾巴的蛇，由此揭开了苯环结构之谜，我们都知道的凯库勒式。虽然某天我偶然得知实际上凯库勒实际上很可能并不是凯库勒首先发现的，但这个蛇图也可以拿来帮助理解切片。
>
> python 可能也是这样的环，并且我由于可以使用负位置，我猜很可能是首尾相连的双向链表来实现序列这个数据结构，即每个节点都有两个指针，一个指向之前，一个指向之后。那么也就是说，按照切片的语法，整个序列的切片可能是 [0:0] 或者 [0:-0] 。根据编译原理，中括号内相当于参数列表，肯定是从左至右扫描的，[0：0] 会让编译器困惑。[0：-0] 也很容易让我们困惑。所以作者想出个巧妙地办法，索性将之缺省。
>
> 这些猜测需要深扒 python ，日后我们再行探究。

你也可以为切片提供第三个参数，它是切片的**步长 (step)** ，类似 `range()`，这个步长默认也为 1 。

```python
>>> shoplist = ['apple', 'mango', 'carrot', 'banana']
>>> shoplist[::1]
['apple', 'mango', 'carrot', 'banana']
>>> shoplist[::2]
['apple', 'carrot']
>>> shoplist[::3]
['apple', 'banana']
>>> shoplist[::-1]
['banana', 'carrot', 'mango', 'apple']
```

请注意，当步长是 2 时，我们取得的项的位置是 0 ，2 等。当步长是 3 ，项的位置是 0 ，3 等。

> 请注意，步长也可以是负数。

在 python 解释器互动命令行中尝试这些不同的切片指定方法，你可以立刻看到结果。序列的最佳之处在于你可以用相同的方式访问列表，元组和字符串。

## 集合 set

集合 (set) 是简单对象的**无序**集合。当某对象在集合中存在与否重于它的顺序或者出现次数的时候，适合使用集合。

使用集合时，你可以有成员关系测试相关的操作，如它是否是其他集合的子集，查找两个集合的交集等等。

```python
>>> bri = set(['brazil', 'russia', 'india'])
>>> 'india' in bri
True
>>> 'usa' in bri
False
>>> bric = bri.copy()
>>> bric.add('china')
>>> bric.issuperset(bri)
True
>>> bri.remove('russia')
>>> bri & bric # OR bri.intersection(bric)
{'brazil', 'india'}
```

**它是怎样做的**

如果你想起校园时期学到的数学理论中集合的基本概念，那这个例子已经能自我说明了。如果没有，你还是百度一下“集合理论”以及“文氏图”来帮助理解 python 中的集合用法。

## 引用 references

当你创建了一个对象并将之赋值给一个变量，这个变量仅仅是这个对象的**引用**，它表示的并不是这个对象本身！也就是说，这个变量名称指向你电脑中存储对象的那块内存。这被称为将名称**绑定 (binding)** 到对象。 

你通常都不必太关心这一点，但有时你还是得意识到引用会引起会产生某些微妙的效果：

请看示例 `ds_reference.py` ：

<pre><code class="lang-python">{% include "./programs/ds_reference.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/ds_reference.txt" %}</code></pre>

**它是怎样做的**

开始的时候将 `shoplist` 赋给 `mylist` ，`mylist` 同 `shoplist` 一样，仅仅是变量名称，它们实际指向同一个对象。所以打印结果是相同的，都没有了 `apple` 。

第二次我们先对 `shoplist` 引用的对象进行切片，再赋给 `mylist` 。这时，`mylist` 与 `shoplist` 已经不同了，它引用的是另一个对象。所以打印结果是不同的，`mylist` 中的 `mango` 没有了，`shoplist` 的还在。

请记住如果你想要复制某列表，或者其他种类的序列，或者是复杂对象（不是像整数那种**简单的对象**），你必须使用切片来制作这个副本。如果你仅仅将变量名称赋给另一个名称，那他们都会“引用”同一个对象。你如果不留心这点，就有可能造成麻烦。

> perl 程序员需要列表的赋值语句并**不创建**副本。
>
> 如果你熟悉其他的面向对象编程语言，那么浅复制和深复制你一定不陌生。实际上切片仅复制一层对象，并不是深复制。
>
> 当列表内的项由引用时，你就能发现这一点。    

## 更多关于字符串的事 {#more-strings}

早些时候，我们已经详细的讨论过字符串了。那么还有其他什么是我们在这要知道的？好吧，你知道字符串也是对象，那你知道它也有能完成从检测字符串的某一部分到去除空格等一系列操作的方法吗？实际上，你已经是用过一个字符串方法了，那就是 `format` 方法！

你在程序中所使用的字符串全部都是类 `str` 的对象。这个类一些很有用的方法在下面的示例中会做以说明。如果你想看这些方法的完整列表，`help(str)` 。

请看示例 `ds_str_methods.py` ：

<pre><code class="lang-python">{% include "./programs/ds_str_methods.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/ds_str_methods.txt" %}</code></pre>

**它是怎样做的**

这里，我们看到一系列字符串方法。`startswith` 方法用来查找字符串是否以给定字符串开头。`in` 操作符用来检测给定字符串是否是某字符串的一部分。

`find` 方法能够在字符串内定位子字符串。如果不能 `find` 返回 -1 。`str` 还有个 `join` 方法，**连接 (join)** 能将字符串作为某序列的项之间的分隔符，并返回以此生成更大的字符串。

## 总结

我们仔细探索了这些 python 内置的数据结构。它们在成规模的程序编写中是不可或缺的。

现在，我们的基础已经比较扎实了，接着我们就要试着设计和编写真正的 python 程序了。