# 解决问题

我们已经学了很多了，现在我们要将这些学以致用。

## 问题

我们想要解决这样一个问题：

> 我想要备份所有重要文件

尽管，这是一个简单问题，但这并没有足够的信息让我们开始编写解决方案。还需要一点点**分析**。例如，**哪些**，**怎样**备份，备份在哪？

正确分析这些问题之后，我们开始**设计**程序。我们制定出一份程序要完成的工作的清单。本例中，下边的这个列表是我想让程序完成的事情。如果你要做这种设计，你也许不必用相同的分析方式，每个人都有他自己的方式。按你适合的方式做即可。

- 要备份的文件和目录应该由一个列表指定。
- 备份必须被放在主备份目录中。
- 文件都被分到一个 zip 压缩文件中。
- 这个 zip 压缩文件的名称是当前日期和时间
- 我们使用标准的 GNU/Linux 或 Unix 发行版中默认的 `zip` 命令。请注意，你可以使用任何你想要的压缩命令，只要它有命令行接口。

> **对 Windows 用户**
> 
> 原著这里指导使用 [zip](http://gnuwin32.sourceforge.net/downlinks/zip.php) 。
> 如果安装了 winrar ，那我们已经可以使用 `rar` 命令了。也许你需要先把它的目录加入到环境变量中。

## 解决方案

我们的程序的设计已经比较稳定了，我们可以编写代码了，也就是**实现**我们的解决方案。

请看示例 `backup_ver1.py` ：

<pre><code class="lang-python">{% include "./programs/backup_ver1.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/backup_ver1.txt" %}</code></pre>

现在，我们处于**测试**阶段，在这里我们测试程序是否能正常工作。如果它的行为和期望有出入，我们必须**调试**程序，也就是从程序中移除 **bug** 。

如果上面的程序在你那并不能正常起作用，将屏幕输出中 `Zip command is` 下面的那行赋值下来，粘贴到 shell 中，看看是出了什么问题，然后修正。同时也别忘给了查看 zip 命令的参考手册。如果命令是没问题的，那么基本上就是 python 程序它自己的问题了。所以查查它是否和写在上面的程序相同。

**它是怎样做的**

你会注意到，我们怎样一步步将我们的**设计**转化成**代码**。

我们首先导入 `os` 和 `time` 模块。然后我们再 `source` 列表中指定要备份的文件和目录。目标目录是我们储存备份文件的目录，它由变量 `target_dir` 指定。我们要创建的 zip 压缩文件的名称是我们使用 `time.strftime()` 函数生成的当前日期和时间。它有着 `.zip` 的扩展名并且会储存在 `target_dir` 目录中。

请看好 `os.sep` 变量的用法——这根据你操作系统给出正确的目录分隔符，也就是说，在 GNU/Linux ，Unix ，macOS 中它是 `'/'` ，而在 Windows 中，会是 `'\\'`。使用 `os.sep` 而不是直接用字符能使我们程序具有便携性 (portable) 能够跨平台运行。

`time.strftime()` 函数接受一种特殊的格式，如我们上面程序中所使用的那样。`%Y` 格式会被带有世纪数的完整年份替换，`%m` 会被月份替换，这些月份的形式是 `01` 到 `12` 之间的十进制数。这种格式的完整列表可以在 [python 引用手册 (Python Reference Manual)](http://docs.python.org/3/library/time.html#time.strftime) 中找到。

我们创建目标 zip 文件名时使用了加运算符，它能**连接**字符串，也就是说它能将两个字符串连接起来并返回一个新字符串。然后，我们新建一个字符串 `zip_command` ，内中是我们将要执行的命令。你可以在 shell 中运行它来看看命令是否正确。

`zip` 命令也有一些可用的选项。其中之一是 `-r` 。`-r` 选项指定 zip 命令对目录迭代执行，也就是说，它将包含所有的子目录以及其中的文件。选项在 zip 压缩文件之后，在要备份的文件和目录列表之前。我们使用了之前讲过的字符串的 `join` 方法将 `source` 列表转化为字符串。

最终，我们使用 `os.system` 函数来**运行**命令。`os.system` 函数运行命令就如同你在**系统**，即 shell ，中运行那些命令。如果命令成功执行，那么它就返回 `0` ，否则它会返回一个错误数字。

根据命令的输出，备份是否成功，我们打印出正确的消息。

就是它，我们创建了一个能备份我们所有重要文件的脚本！

> **对于 Windows 用户**
> 
> 我们可以使用原字符串来替代双反斜杠的转义序列。例如，`r'C:\Documents'` 代替 `'C:\\Documents'` 。但是**不要**用 `'C:\Documents'` 由于它会被认作位置转义序列 `\D` 。
>
> 其实我们在 Windows 中安装 git 时，很多工具也随之安装。其中有 git-bash 可以为你提供 Unix 或 Linux 系的 shell 环境。`'C:\Documents'` 在那里你可以写作 `'/C/Documents'` 。

现在，我们有了一个能正确起作用的备份脚本，我们可以随意使用它来备份文件。这叫做软件的**操作**阶段或者**部署 (deployment)** 阶段。

虽然上面的示例程序能正常工作，但是通常第一个程序都不会那么如意。例如，可能有些问题在你设计程序的时候想的不那么周到，或者当你编码时有些输入错误等等。在适当的时候，你要回到设计阶段调整，或者调试程序。

## 第二版本

我们脚本的第一版本是能正常工作的。但是，我们可以优化它，来是它能够在日常使用中表现的更好。这被称作软件的**维护**阶段。

一种我认为很有用的优化是良好的文件命名机制——在主备份目录中，使用**日期**目录名，使用**时间**作为文件名。这种方式带来的第一个优势就是你的备份储存的架构很清晰，较容易管理。第二个好处是文件名会比较短。第三个好处是独立的目录能帮你检测你是否每天天都做备份因为只有你在那天做了备份，这个目录才会被创建。

请看示例 `backup_ver2.py` ：

<pre><code class="lang-python">{% include "./programs/backup_ver2.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/backup_ver2.txt" %}</code></pre>

**它是怎样做的**

程序的大部分都没有变动。变化之处在于我们使用 `os.path.exists` 函数在主备份目录中检测是否存在当天的辈分目录。如果不存在，我们使用 `os.mkdir` 函数来创建它。


## 第三版本

备份数不是特别多的时候，第二版本还是不错的。但是当备份数成规模的时候，我发现很难分辨为什么要备份！举个例子，也许我对程序或者描述做了些重要修改，我想要将这些修改与 zip 压缩文件的名称有所联系。为 zip 压缩文件名附加用户提供 (user-supplied) 注释可以轻松做到这一点点。

请注意：下面的程序并不能正常工作，不要慌，请紧跟我的脚步，在这里还有一课要学。

请看示例 `backup_ver3.py` ：

<pre><code class="lang-python">{% include "./programs/backup_ver3.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/backup_ver3.txt" %}</code></pre>

**它怎样做（错）的**

**这个程序并不能正常工作！**python 会告诉你这有个语法错误，意思是脚本并不符合 python 要求的结构。当我们看到 python 给出的错误提示的时候，它还告诉了我们这个错误是在哪里侦测到的。所以从那开始**调试**我们的程序。

仔细观察，我们看到一行逻辑行被分解为两行物理行。但是我们没有指定这两行物理行是一起的。基本来说，python 发现在逻辑行内加操作符 `+` 没有操作数，因此它不知怎样继续下去。请记好，我们可以在物理行末尾使用反斜杠来指定逻辑行延续到了下面的物理行。所以，我们在程序中纠正这个问题，这叫做**bug 修复 (fixing)** 。

## 第四版本

`backup_ver4.py` ：

<pre><code class="lang-python">{% include "./programs/backup_ver4.py" %}</code></pre>

输出为：

<pre><code>{% include "./programs/backup_ver4.txt" %}</code></pre>

**它怎样做的**

现在程序正常了！让我们扒扒我们在版本 3 上做了哪些强化。我们使用 `input` 函数获取用户的注释，然后通过用 `len` 函数获取输入的长度来检测用户是否真的输入了什么。如果用户仅仅是按了 `enter` 而没有输入任何东西（也许仅是个路径备份或者没什么特殊的改变），那我们就如同之前那样处理。

但是，如果用户提供了注释，那注释就被附加到文件名中，在 `.zip` 扩展名之前。请注意，我们使用下划线替换了注释中的空格——因为没有空格的文件名管理起来更加容易。

## 更多优化

第四版本对大多数用户来说，已经是比较满意了，但是还是有提升空间。举例说，你可以在 zip 命令中包括**赘言 (verbosity)** 等级，指定 `-v` 选项，它可以让你的程序更健谈，或者 `-q` 选项来使它**沉默**。

另一个可能强化方向是在命令行中允许额外的文件和目录传递给脚本。我们能从 `sys.argv` 列表中得到这些名称，然后使用 `list` 类提供的 `extend` 方法来将之添加到我们的 `source` 列表中。

最重要的优化应该使用 [zipfile](http://docs.python.org/3/library/zipfile.html) 或 [tarfile](http://docs.python.org/3/library/tarfile.html) 内置模块来创建压缩文件，而不是调用 `os.system` 。它们是标准库的一部分，并且想用就用，没有外部依赖，也就是说你不需要保证你电脑上有 zip 程序可用。

但是，在上例中，为了做演示，我使用 `os.system` 创建了备份。所以这个例子通俗易懂但并不那么实用。

你可以试着完成使用 [zipfile](http://docs.python.org/3/library/zipfile.html) 模块代替 `os.system` 调用的第五版本。

## 软件开发流程

我们已然经历了多个编写软件的**阶段**。这些阶段总结如下：

1. What (分析)
2. How (设计)
3. Do (实现)
4. Test (测试调试)
5. Use (部署)
6. Maintain (优化)

> 几经考虑，最终保留了原著文字，因为它们更容易理解和记忆。

编写程序的一种荐方式就是遵循我们开发备份脚本的时跟随的这个过程：分析设计，开始实现简单版本。测试调试，使用，确保它能正常工作。现在，你可以添加你想要的特性，按需重复这实现-测试-部署的循环，

请记住

> 软件是长成的，不是建成的。

## 总结

我们已经了解如何创建我们自己的 python 程序或脚本以及编写软件所涉及的国歌阶段。你也许会发现我们在本章的所作所为在实际开发时比较有用，这样 python 语言以及用 python 解决问题会让你感到舒适。

下面，我们来讨论面向对象编程 (object-oriented programming) 。